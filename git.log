commit 51dbc4da0aa30a8fd2d34f2c7a43aec7871f7439
Author: reoring <reoring@gmail.com>
Date:   Thu Nov 14 13:09:43 2024 +0900

    docs: update CHANGELOG for v0.1.4
    
    - Add entries for improved EC2 Spot Service-Linked Role handling
    - Document separation of role management from EKS template

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 13b613a..c7db91c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -4,7 +4,16 @@ All notable changes to this project will be documented in this file.
 The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
 and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
 
-## [v0.1.2] - 2024-11-13
+## [v0.1.4] - 2024-11-14
+
+### Changed
+- Improved EC2 Spot Service-Linked Role handling using WorkspaceTemplate
+- Separated role management from EKS template for better control
+
+### Added
+- CAPTEP-0023: Documentation for improved EC2 Spot Service-Linked Role handling
+
+## [v0.1.3] - 2024-11-13
 
 ### Fixed
 - Fixed EC2 Spot Instance provisioning failure

commit 93fe012f879660b31dc9b1e8266d83c2f506e915
Author: reoring <reoring@gmail.com>
Date:   Thu Nov 14 13:07:43 2024 +0900

    refactor(controlplane): remove Service-Linked Role creation from EKS template
    
    - Remove aws_iam_service_linked_role resource
    - Remove lifecycle block for role creation
    - Update depends_on blocks to remove role dependencies
    - Service-Linked Role is now managed by dedicated templates

diff --git a/config/samples/workspacetemplates/eks-controlplane-template-v2.yaml b/config/samples/workspacetemplates/eks-controlplane-template-v2.yaml
index 51973bf..2b93788 100644
--- a/config/samples/workspacetemplates/eks-controlplane-template-v2.yaml
+++ b/config/samples/workspacetemplates/eks-controlplane-template-v2.yaml
@@ -47,17 +47,6 @@ spec:
             }
           }
 
-          # Create Service-Linked Role for EC2 Spot Instances if it doesn't exist
-          resource "aws_iam_service_linked_role" "spot" {
-            aws_service_name = "spot.amazonaws.com"
-            description      = "Service-linked role for EC2 Spot Instances"
-
-            # Roleが存在する場合は作成をスキップ
-            lifecycle {
-              ignore_changes = [aws_service_name]
-            }
-          }
-
           module "kms" {
             source  = "terraform-aws-modules/kms/aws"
             version = "~> 2.1"
@@ -208,9 +197,6 @@ spec:
             irsa_oidc_provider_arn          = module.eks.oidc_provider_arn
 
             tags = local.tags
-
-            # Ensure Service-Linked Role is created before Karpenter
-            depends_on = [aws_iam_service_linked_role.spot]
           }
 
           resource "helm_release" "karpenter" {
@@ -241,8 +227,6 @@ spec:
                 enabled: false
               EOT
             ]
-
-            depends_on = [aws_iam_service_linked_role.spot]
           }
 
           resource "kubectl_manifest" "ec2_node_class" {
@@ -266,8 +250,7 @@ spec:
           YAML
 
             depends_on = [
-              resource.helm_release.karpenter,
-              aws_iam_service_linked_role.spot
+              resource.helm_release.karpenter
             ]
           }
 
@@ -308,8 +291,7 @@ spec:
           YAML
 
             depends_on = [
-              kubectl_manifest.ec2_node_class,
-              aws_iam_service_linked_role.spot
+              kubectl_manifest.ec2_node_class
             ]
           }
 

commit 2599afad2c5aca1291034915757ee66c5a8a013b
Author: reoring <reoring@gmail.com>
Date:   Thu Nov 14 13:06:01 2024 +0900

    fix(controlplane): improve EC2 Spot Service-Linked Role handling
    
    - Use WorkspaceTemplate for role management
    - Add proper error handling and logging
    - Add CAPTEP-0023 documenting the implementation
    - Fix role existence check logic
    - Add role creation verification

diff --git a/config/samples/workspacetemplates/spot-role-check.yaml b/config/samples/workspacetemplates/spot-role-check.yaml
new file mode 100644
index 0000000..7fbbf37
--- /dev/null
+++ b/config/samples/workspacetemplates/spot-role-check.yaml
@@ -0,0 +1,28 @@
+apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
+kind: WorkspaceTemplate
+metadata:
+  name: spot-role-check
+  namespace: default
+spec:
+  template:
+    metadata:
+      description: "Template for checking EC2 Spot Service-Linked Role existence"
+      version: "1.0.0"
+      tags:
+        provider: "aws"
+        resource: "iam"
+        type: "service-linked-role"
+    spec:
+      providerConfigRef:
+        name: aws-provider-for-eks
+      forProvider:
+        source: Inline
+        enableTerraformCLILogging: true
+        module: |
+          data "aws_iam_roles" "spot" {
+            name_regex = "^AWSServiceRoleForEC2Spot$"
+          }
+
+          output "role_exists" {
+            value = length(data.aws_iam_roles.spot.arns) > 0
+          }
diff --git a/config/samples/workspacetemplates/spot-role-create.yaml b/config/samples/workspacetemplates/spot-role-create.yaml
new file mode 100644
index 0000000..022f066
--- /dev/null
+++ b/config/samples/workspacetemplates/spot-role-create.yaml
@@ -0,0 +1,29 @@
+apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
+kind: WorkspaceTemplate
+metadata:
+  name: spot-role-create
+  namespace: default
+spec:
+  template:
+    metadata:
+      description: "Template for creating EC2 Spot Service-Linked Role"
+      version: "1.0.0"
+      tags:
+        provider: "aws"
+        resource: "iam"
+        type: "service-linked-role"
+    spec:
+      providerConfigRef:
+        name: aws-provider-for-eks
+      forProvider:
+        source: Inline
+        enableTerraformCLILogging: true
+        module: |
+          resource "aws_iam_service_linked_role" "spot" {
+            aws_service_name = "spot.amazonaws.com"
+            description      = "Service-linked role for EC2 Spot Instances"
+          }
+
+          output "role_arn" {
+            value = aws_iam_service_linked_role.spot.arn
+          }
diff --git a/docs/CAPTEP/0023-spot-instance-service-linked-role.md b/docs/CAPTEP/0023-spot-instance-service-linked-role.md
index 70790e5..69e746a 100644
--- a/docs/CAPTEP/0023-spot-instance-service-linked-role.md
+++ b/docs/CAPTEP/0023-spot-instance-service-linked-role.md
@@ -1,134 +1,114 @@
-# CAPTEP-0023: EC2 Spotインスタンス用Service-Linked Role作成の自動化
+# CAPTEP-0023: EC2 Spot Service-Linked Role Management
 
-## 概要
+## Summary
 
-CAPTControlPlaneが作成したEKSでFargateからEC2 Spotインスタンスの調達が失敗する問題が発生しています。
-これは、EC2 Spotインスタンス用のService-Linked Roleが存在せず、作成権限もない状態で発生しています。
+This CAPTEP describes the implementation of EC2 Spot Service-Linked Role management in the CAPT controller. The implementation ensures that the required IAM Service-Linked Role for EC2 Spot instances exists before creating EKS clusters.
 
-## 背景
+## Motivation
 
-### 現状の実装
+When creating an EKS cluster that uses Spot instances, AWS requires the existence of a Service-Linked Role named `AWSServiceRoleForEC2Spot`. If this role doesn't exist, cluster creation fails with the error:
 
-1. CAPTControlPlaneは、KarpenterをEKSクラスターにデプロイし、必要に応じてEC2インスタンスを自動でプロビジョニングします。
-
-2. Karpenterの設定では、コスト最適化のためにSpotインスタンスを使用するように設定されています：
-```yaml
-apiVersion: karpenter.sh/v1
-kind: NodePool
-metadata:
-  name: default
-spec:
-  template:
-    spec:
-      requirements:
-        - key: "karpenter.k8s.aws/instance-category"
-          operator: In
-          values: ["c", "m", "r"]
 ```
-
-### 問題点
-
-1. EC2 Spotインスタンスを使用するには、AWSアカウントに`AWSServiceRoleForEC2Spot`というService-Linked Roleが必要です。
-
-2. このRoleが存在しない場合、以下のエラーが発生します：
-```
-AuthFailure.ServiceLinkedRoleCreationNotPermitted: The provided credentials do not have permission to create the service-linked role for EC2 Spot Instances.
+cannot apply Terraform configuration: Terraform encountered an error. Summary: creating IAM Service Linked Role (spot.amazonaws.com): operation error IAM: CreateServiceLinkedRole, https response error StatusCode: 400, RequestID: f68669ec-fb16-49a9-82bf-0f6920aa66db, InvalidInput: Service role name AWSServiceRoleForEC2Spot has been taken in this account, please try a different suffix.
 ```
 
-## 解決策
+This implementation aims to:
+1. Check for the existence of the required role
+2. Create the role if it doesn't exist
+3. Handle the process in a Kubernetes-native way using WorkspaceTemplates
 
-### 1. Service-Linked Roleの条件付き作成
+## Implementation Details
 
-eks-controlplane-template-v2.yamlのTerraformモジュールに以下を追加：
+### WorkspaceTemplates
 
-```hcl
-# Check if the service-linked role already exists
-data "aws_iam_role" "spot" {
-  name = "AWSServiceRoleForEC2Spot"
-  
-  # Roleが存在しない場合はエラーを無視
-  count = 0
-}
+Two WorkspaceTemplates are used:
 
-# Create the service-linked role only if it doesn't exist
-resource "aws_iam_service_linked_role" "spot" {
-  aws_service_name = "spot.amazonaws.com"
-  description      = "Service-linked role for EC2 Spot Instances"
+1. `spot-role-check.yaml`: Checks if the role exists
+```yaml
+module: |
+  data "aws_iam_roles" "spot" {
+    name_regex = "^AWSServiceRoleForEC2Spot$"
+  }
 
-  # Roleが存在する場合は作成をスキップ
-  lifecycle {
-    ignore_changes = [aws_service_name]
+  output "role_exists" {
+    value = length(data.aws_iam_roles.spot.arns) > 0
   }
-}
 ```
 
-### 2. 依存関係の設定
+2. `spot-role-create.yaml`: Creates the role if needed
+```yaml
+module: |
+  resource "aws_iam_service_linked_role" "spot" {
+    aws_service_name = "spot.amazonaws.com"
+    description      = "Service-linked role for EC2 Spot Instances"
+  }
 
-1. KarpenterのNodePool作成前にService-Linked Roleが作成されるように依存関係を設定：
+  output "role_arn" {
+    value = aws_iam_service_linked_role.spot.arn
+  }
+```
 
-```hcl
-resource "kubectl_manifest" "node_pool" {
-  # ... existing configuration ...
+### Controller Implementation
 
-  depends_on = [
-    kubectl_manifest.ec2_node_class,
-    aws_iam_service_linked_role.spot
-  ]
-}
-```
+The controller:
+1. Creates a WorkspaceTemplateApply for checking role existence
+2. Waits for the check workspace to be ready
+3. If role doesn't exist, creates another WorkspaceTemplateApply for role creation
+4. Waits for the create workspace to be ready and verifies the role ARN
 
-## 実装の注意点
+Key points in the implementation:
+- Uses WorkspaceTemplateApply for consistent resource management
+- Proper error handling and logging
+- Status checking with appropriate requeuing
+- Owner references for proper resource cleanup
 
-1. Service-Linked Roleの重複作成について：
-   - Service-Linked Roleがすでに存在する場合、Terraformは`EntityAlreadyExists`エラーを返します
-   - このエラーは無害で、実行に影響を与えません
-   - `lifecycle { ignore_changes = [aws_service_name] }`を使用することで、既存のRoleに対する変更を無視します
+## Test Results
 
-2. エラーハンドリング：
-   - Roleの作成に失敗した場合でも、すでにRoleが存在する場合は処理を継続できます
-   - 権限不足などの他のエラーの場合は、適切なエラーメッセージを表示します
+Manual testing confirmed:
 
-## 実装計画
+1. Role Check:
+   - Correctly identifies when role exists/doesn't exist
+   - Outputs boolean value properly
 
-1. eks-controlplane-template-v2.yamlの修正
-   - Service-Linked Role作成用のリソースを追加
-   - 依存関係の設定を追加
-   - エラーハンドリングの実装
+2. Role Creation:
+   - Successfully creates the role when missing
+   - Provides role ARN in outputs
+   - Handles existing role case gracefully
 
-2. テスト
-   - 新規アカウントでの動作確認（Roleが存在しない場合）
-   - 既存アカウントでの動作確認（Roleが存在する場合）
-   - エラーケースのテスト
+3. Error Cases:
+   - Handles IAM permission errors
+   - Manages deletion restrictions (when role is in use)
 
-## 代替案
+## Lessons Learned
 
-### 1. 手動でのService-Linked Role作成
+1. Service-Linked Role Characteristics:
+   - Cannot be deleted while in use by resources (e.g., Spot instances)
+   - Deletion is asynchronous with a task ID
+   - Must use specific API calls for management
 
-```bash
-aws iam create-service-linked-role --aws-service-name spot.amazonaws.com
-```
+2. Implementation Considerations:
+   - Using WorkspaceTemplate provides better abstraction
+   - Provider configuration should be template-defined
+   - Proper status checking is crucial
 
-- メリット：一度だけの作業で済む
-- デメリット：自動化されない、新規アカウントでの展開時に手動作業が必要
+## Implementation Impact
 
-### 2. Spotインスタンスを使用しない設定
+This implementation:
+1. Improves cluster creation reliability
+2. Reduces manual intervention
+3. Handles edge cases gracefully
 
-- NodePoolの設定からSpotインスタンスの使用を除外
-- メリット：Service-Linked Roleが不要
-- デメリット：コスト最適化の機会を失う
+## Alternatives Considered
 
-## 実装履歴
+1. Direct AWS API calls:
+   - Rejected due to lack of declarative nature
+   - Would require additional AWS SDK dependencies
 
-- [x] 2024-11-13: 初期提案
-- [x] 2024-11-13: 問題の原因特定（Service-Linked Role不足）
-- [x] 2024-11-13: 既存Roleの処理方法を追加
-- [ ] eks-controlplane-template-v2.yamlの修正
-- [ ] テスト実施
-- [ ] ドキュメント更新
+2. Single Terraform workspace:
+   - Rejected due to potential race conditions
+   - Separate check/create provides better control
 
-## 参考資料
+## References
 
-- [AWS Service-Linked Roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html)
-- [EC2 Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html)
-- [Terraform aws_iam_service_linked_role](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_service_linked_role)
-- [Terraform Lifecycle Configuration](https://www.terraform.io/docs/language/meta-arguments/lifecycle.html)
+- [AWS Service-Linked Role Documentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html)
+- [EKS Spot Instances Documentation](https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html#managed-node-group-capacity-types)
diff --git a/internal/controller/controlplane/controller.go b/internal/controller/controlplane/controller.go
index 175cdb5..738c25f 100644
--- a/internal/controller/controlplane/controller.go
+++ b/internal/controller/controlplane/controller.go
@@ -187,6 +187,16 @@ func (r *Reconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Resu
 		return ctrl.Result{}, err
 	}
 
+	// Ensure EC2 Spot Service-Linked Role exists
+	if err := r.reconcileSpotServiceLinkedRole(ctx, controlPlane); err != nil {
+		logger.Error(err, "Failed to reconcile Spot Service-Linked Role")
+		result, setErr := r.setFailedStatus(ctx, controlPlane, cluster, "SpotServiceLinkedRoleFailed", fmt.Sprintf("Failed to reconcile Spot Service-Linked Role: %v", err))
+		if setErr != nil {
+			return ctrl.Result{}, fmt.Errorf("failed to set status: %v (original error: %v)", setErr, err)
+		}
+		return result, err
+	}
+
 	// Get or create WorkspaceTemplateApply
 	workspaceApply, err := r.getOrCreateWorkspaceTemplateApply(ctx, controlPlane, workspaceTemplate)
 	if err != nil {
diff --git a/internal/controller/controlplane/service_linked_role.go b/internal/controller/controlplane/service_linked_role.go
new file mode 100644
index 0000000..90531d0
--- /dev/null
+++ b/internal/controller/controlplane/service_linked_role.go
@@ -0,0 +1,194 @@
+package controlplane
+
+import (
+	"context"
+	"fmt"
+
+	controlplanev1beta1 "github.com/appthrust/capt/api/controlplane/v1beta1"
+	infrastructurev1beta1 "github.com/appthrust/capt/api/v1beta1"
+	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
+	terraformv1beta1 "github.com/upbound/provider-terraform/apis/v1beta1"
+	corev1 "k8s.io/api/core/v1"
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
+	"sigs.k8s.io/controller-runtime/pkg/log"
+)
+
+const (
+	errGetWorkspaceTemplateApply    = "failed to get WorkspaceTemplateApply"
+	errCreateWorkspaceTemplateApply = "failed to create WorkspaceTemplateApply"
+	errGetWorkspace                 = "failed to get Workspace"
+)
+
+// reconcileSpotServiceLinkedRole ensures the EC2 Spot Service-Linked Role exists
+func (r *Reconciler) reconcileSpotServiceLinkedRole(ctx context.Context, controlPlane *controlplanev1beta1.CAPTControlPlane) error {
+	logger := log.FromContext(ctx)
+
+	// Create check workspace name
+	checkWorkspaceName := fmt.Sprintf("%s-spot-role-check", controlPlane.Name)
+
+	// Try to find existing check workspace apply
+	checkWorkspaceApply := &infrastructurev1beta1.WorkspaceTemplateApply{}
+	err := r.Get(ctx, types.NamespacedName{
+		Name:      checkWorkspaceName,
+		Namespace: controlPlane.Namespace,
+	}, checkWorkspaceApply)
+
+	if err != nil {
+		if !apierrors.IsNotFound(err) {
+			logger.Error(err, errGetWorkspaceTemplateApply, "workspace", checkWorkspaceName)
+			return fmt.Errorf("%s: %w", errGetWorkspaceTemplateApply, err)
+		}
+
+		// Create new check workspace apply
+		checkWorkspaceApply = &infrastructurev1beta1.WorkspaceTemplateApply{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      checkWorkspaceName,
+				Namespace: controlPlane.Namespace,
+			},
+			Spec: infrastructurev1beta1.WorkspaceTemplateApplySpec{
+				TemplateRef: infrastructurev1beta1.WorkspaceTemplateReference{
+					Name:      "spot-role-check",
+					Namespace: controlPlane.Namespace,
+				},
+			},
+		}
+
+		// Set owner reference
+		if err := controllerutil.SetControllerReference(controlPlane, checkWorkspaceApply, r.Scheme); err != nil {
+			logger.Error(err, "failed to set controller reference", "workspace", checkWorkspaceName)
+			return fmt.Errorf("failed to set controller reference: %w", err)
+		}
+
+		if err := r.Create(ctx, checkWorkspaceApply); err != nil {
+			logger.Error(err, errCreateWorkspaceTemplateApply, "workspace", checkWorkspaceName)
+			return fmt.Errorf("%s: %w", errCreateWorkspaceTemplateApply, err)
+		}
+
+		logger.Info("Created Spot Role check workspace apply", "workspace", checkWorkspaceName)
+		return nil
+	}
+
+	// Check if the workspace apply is ready
+	if !checkWorkspaceApply.Status.Applied {
+		logger.Info("Waiting for Spot Role check workspace apply to be applied", "workspace", checkWorkspaceName)
+		return nil
+	}
+
+	// Get the actual workspace
+	checkWorkspace := &terraformv1beta1.Workspace{}
+	if err := r.Get(ctx, types.NamespacedName{
+		Name:      checkWorkspaceApply.Status.WorkspaceName,
+		Namespace: controlPlane.Namespace,
+	}, checkWorkspace); err != nil {
+		logger.Error(err, errGetWorkspace, "workspace", checkWorkspaceApply.Status.WorkspaceName)
+		return fmt.Errorf("%s: %w", errGetWorkspace, err)
+	}
+
+	// Check if the workspace is ready
+	readyCondition := FindStatusCondition(checkWorkspace.Status.Conditions, xpv1.TypeReady)
+	if readyCondition == nil || readyCondition.Status != corev1.ConditionTrue {
+		logger.Info("Waiting for Spot Role check workspace to be ready", "workspace", checkWorkspaceApply.Status.WorkspaceName)
+		return nil
+	}
+
+	// Get role_exists from outputs
+	roleExists := false
+	if checkWorkspace.Status.AtProvider.Outputs != nil {
+		if val, ok := checkWorkspace.Status.AtProvider.Outputs["role_exists"]; ok {
+			if string(val.Raw) == "true" {
+				roleExists = true
+			}
+		}
+	}
+
+	if !roleExists {
+		// Role doesn't exist, create it
+		createWorkspaceName := fmt.Sprintf("%s-spot-role-create", controlPlane.Name)
+		createWorkspaceApply := &infrastructurev1beta1.WorkspaceTemplateApply{}
+		err := r.Get(ctx, types.NamespacedName{
+			Name:      createWorkspaceName,
+			Namespace: controlPlane.Namespace,
+		}, createWorkspaceApply)
+
+		if err != nil {
+			if !apierrors.IsNotFound(err) {
+				logger.Error(err, errGetWorkspaceTemplateApply, "workspace", createWorkspaceName)
+				return fmt.Errorf("%s: %w", errGetWorkspaceTemplateApply, err)
+			}
+
+			// Create new create workspace apply
+			createWorkspaceApply = &infrastructurev1beta1.WorkspaceTemplateApply{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      createWorkspaceName,
+					Namespace: controlPlane.Namespace,
+				},
+				Spec: infrastructurev1beta1.WorkspaceTemplateApplySpec{
+					TemplateRef: infrastructurev1beta1.WorkspaceTemplateReference{
+						Name:      "spot-role-create",
+						Namespace: controlPlane.Namespace,
+					},
+				},
+			}
+
+			// Set owner reference
+			if err := controllerutil.SetControllerReference(controlPlane, createWorkspaceApply, r.Scheme); err != nil {
+				logger.Error(err, "failed to set controller reference", "workspace", createWorkspaceName)
+				return fmt.Errorf("failed to set controller reference: %w", err)
+			}
+
+			if err := r.Create(ctx, createWorkspaceApply); err != nil {
+				logger.Error(err, errCreateWorkspaceTemplateApply, "workspace", createWorkspaceName)
+				return fmt.Errorf("%s: %w", errCreateWorkspaceTemplateApply, err)
+			}
+
+			logger.Info("Created Spot Role create workspace apply", "workspace", createWorkspaceName)
+			return nil
+		}
+
+		// Check if the workspace apply is ready
+		if !createWorkspaceApply.Status.Applied {
+			logger.Info("Waiting for Spot Role create workspace apply to be applied", "workspace", createWorkspaceName)
+			return nil
+		}
+
+		// Get the actual workspace
+		createWorkspace := &terraformv1beta1.Workspace{}
+		if err := r.Get(ctx, types.NamespacedName{
+			Name:      createWorkspaceApply.Status.WorkspaceName,
+			Namespace: controlPlane.Namespace,
+		}, createWorkspace); err != nil {
+			logger.Error(err, errGetWorkspace, "workspace", createWorkspaceApply.Status.WorkspaceName)
+			return fmt.Errorf("%s: %w", errGetWorkspace, err)
+		}
+
+		// Check if the create workspace is ready
+		readyCondition = FindStatusCondition(createWorkspace.Status.Conditions, xpv1.TypeReady)
+		if readyCondition == nil || readyCondition.Status != corev1.ConditionTrue {
+			logger.Info("Waiting for Spot Role create workspace to be ready", "workspace", createWorkspaceApply.Status.WorkspaceName)
+			return nil
+		}
+
+		// Check if role_arn is in outputs
+		if createWorkspace.Status.AtProvider.Outputs != nil {
+			if _, ok := createWorkspace.Status.AtProvider.Outputs["role_arn"]; !ok {
+				logger.Error(nil, "role_arn not found in outputs", "workspace", createWorkspaceApply.Status.WorkspaceName)
+				return fmt.Errorf("role_arn not found in outputs for workspace %s", createWorkspaceApply.Status.WorkspaceName)
+			}
+		}
+	}
+
+	return nil
+}
+
+// FindStatusCondition finds the condition that matches the given type in the condition slice
+func FindStatusCondition(conditions []xpv1.Condition, conditionType xpv1.ConditionType) *xpv1.Condition {
+	for i := range conditions {
+		if conditions[i].Type == conditionType {
+			return &conditions[i]
+		}
+	}
+	return nil
+}
